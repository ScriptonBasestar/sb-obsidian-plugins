/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AwesomePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/template-parser.ts
var TemplateParser = class {
  static parseTemplate(name, content, path) {
    const result = {
      name,
      content,
      body: content,
      path,
      metadata: {},
      variables: [],
      isValid: true,
      errors: []
    };
    try {
      const frontmatterMatch = content.match(this.FRONTMATTER_REGEX);
      if (frontmatterMatch) {
        const [, frontmatterContent, bodyContent] = frontmatterMatch;
        result.body = bodyContent.trim();
        result.metadata = this.parseFrontmatter(frontmatterContent);
      }
      result.variables = this.extractVariables(result.body);
      const validation = this.validateTemplate(result);
      result.isValid = validation.isValid;
      result.errors = validation.errors;
      return result;
    } catch (error) {
      result.isValid = false;
      result.errors.push(`Failed to parse template: ${error.message}`);
      return result;
    }
  }
  static parseFrontmatter(frontmatterContent) {
    const metadata = {};
    const lines = frontmatterContent.trim().split("\n");
    for (const line of lines) {
      const match = line.match(/^(\w+):\s*(.+)$/);
      if (match) {
        const [, key, value] = match;
        const trimmedValue = value.trim();
        switch (key.toLowerCase()) {
          case "title":
            metadata.title = trimmedValue.replace(/['"]/g, "");
            break;
          case "description":
            metadata.description = trimmedValue.replace(/['"]/g, "");
            break;
          case "category":
            metadata.category = trimmedValue.replace(/['"]/g, "");
            break;
          case "tags":
            metadata.tags = this.parseArrayValue(trimmedValue);
            break;
          case "variables":
            metadata.variables = this.parseArrayValue(trimmedValue);
            break;
          case "author":
            metadata.author = trimmedValue.replace(/['"]/g, "");
            break;
          case "version":
            metadata.version = trimmedValue.replace(/['"]/g, "");
            break;
          case "created":
            metadata.created = trimmedValue.replace(/['"]/g, "");
            break;
          case "modified":
            metadata.modified = trimmedValue.replace(/['"]/g, "");
            break;
        }
      }
    }
    return metadata;
  }
  static parseArrayValue(value) {
    if (value.startsWith("[") && value.endsWith("]")) {
      const arrayContent = value.slice(1, -1);
      return arrayContent.split(",").map((item) => item.trim().replace(/['"]/g, "")).filter((item) => item.length > 0);
    }
    return value.split(",").map((item) => item.trim().replace(/['"]/g, "")).filter((item) => item.length > 0);
  }
  static extractVariables(content) {
    const variables = /* @__PURE__ */ new Set();
    let match;
    this.VARIABLE_REGEX.lastIndex = 0;
    while ((match = this.VARIABLE_REGEX.exec(content)) !== null) {
      const variable = match[1].trim();
      if (variable) {
        variables.add(variable);
      }
    }
    return Array.from(variables).sort();
  }
  static validateTemplate(template) {
    const errors = [];
    if (!template.body || template.body.trim().length === 0) {
      errors.push("Template body is empty");
    }
    const malformedVariables = this.findMalformedVariables(template.body);
    if (malformedVariables.length > 0) {
      errors.push(`Malformed variables found: ${malformedVariables.join(", ")}`);
    }
    if (template.metadata.variables) {
      const undefinedVars = template.metadata.variables.filter(
        (v) => !template.variables.includes(v)
      );
      if (undefinedVars.length > 0) {
        errors.push(`Variables declared in frontmatter but not used: ${undefinedVars.join(", ")}`);
      }
    }
    const longVariables = template.variables.filter((v) => v.length > 50);
    if (longVariables.length > 0) {
      errors.push(`Unusually long variable names found: ${longVariables.join(", ")}`);
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  static findMalformedVariables(content) {
    const malformed = [];
    const unclosedStart = content.match(/\{\{[^}]*$/gm);
    const unclosedEnd = content.match(/^[^{]*\}\}/gm);
    if (unclosedStart) {
      malformed.push(...unclosedStart);
    }
    if (unclosedEnd) {
      malformed.push(...unclosedEnd);
    }
    const emptyVariables = content.match(/\{\{\s*\}\}/g);
    if (emptyVariables) {
      malformed.push(...emptyVariables);
    }
    return malformed;
  }
  static getTemplatePreview(template) {
    const maxLength = 150;
    let preview = template.body;
    preview = preview.replace(/^---[\s\S]*?---\n/, "");
    preview = preview.replace(this.VARIABLE_REGEX, (match, variable) => {
      switch (variable.toLowerCase()) {
        case "date":
        case "today":
          return (/* @__PURE__ */ new Date()).toLocaleDateString();
        case "time":
          return (/* @__PURE__ */ new Date()).toLocaleTimeString();
        case "title":
          return "[Title]";
        case "author":
          return "[Author]";
        default:
          return `[${variable}]`;
      }
    });
    if (preview.length > maxLength) {
      preview = preview.substring(0, maxLength) + "...";
    }
    return preview.trim();
  }
};
TemplateParser.FRONTMATTER_REGEX = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
TemplateParser.VARIABLE_REGEX = /\{\{([^}]+)\}\}/g;

// src/template-cache.ts
var import_obsidian = require("obsidian");
var TemplateCache = class {
  // 5 seconds
  constructor(vault, templateFolder) {
    this.cache = /* @__PURE__ */ new Map();
    this.lastScanTime = 0;
    this.scanInterval = 5e3;
    this.vault = vault;
    this.templateFolder = templateFolder;
    this.setupFileWatcher();
  }
  setupFileWatcher() {
    this.vault.on("create", (file) => {
      if (file instanceof import_obsidian.TFile && this.isTemplateFile(file)) {
        this.invalidateCache();
      }
    });
    this.vault.on("delete", (file) => {
      if (file instanceof import_obsidian.TFile && this.isTemplateFile(file)) {
        this.removeFromCache(file.path);
        this.invalidateCache();
      }
    });
    this.vault.on("modify", (file) => {
      if (file instanceof import_obsidian.TFile && this.isTemplateFile(file)) {
        this.removeFromCache(file.path);
        this.invalidateCache();
      }
    });
    this.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian.TFile && this.isTemplateFile(file) || oldPath.startsWith(this.templateFolder)) {
        this.removeFromCache(oldPath);
        if (file instanceof import_obsidian.TFile) {
          this.removeFromCache(file.path);
        }
        this.invalidateCache();
      }
    });
  }
  isTemplateFile(file) {
    return file.path.startsWith(this.templateFolder) && file.extension === "md";
  }
  async getTemplates() {
    const now = Date.now();
    if (now - this.lastScanTime > this.scanInterval) {
      await this.scanForNewFiles();
      this.lastScanTime = now;
    }
    const cachedTemplates = [];
    const templateFiles = this.vault.getFiles().filter((file) => this.isTemplateFile(file));
    for (const file of templateFiles) {
      const template = await this.getTemplate(file);
      if (template) {
        cachedTemplates.push(template);
      }
    }
    return cachedTemplates;
  }
  async getTemplate(file) {
    const cacheKey = file.path;
    const cached = this.cache.get(cacheKey);
    if (cached && this.isCacheValid(cached, file)) {
      return cached.template;
    }
    try {
      const content = await this.vault.read(file);
      const parsedTemplate = TemplateParser.parseTemplate(file.basename, content, file.path);
      this.cache.set(cacheKey, {
        template: parsedTemplate,
        lastModified: file.stat.mtime,
        fileSize: file.stat.size
      });
      return parsedTemplate;
    } catch (error) {
      console.warn(`Failed to read and cache template file: ${file.path}`, error);
      return null;
    }
  }
  isCacheValid(cached, file) {
    return cached.lastModified === file.stat.mtime && cached.fileSize === file.stat.size;
  }
  async scanForNewFiles() {
    const templateFiles = this.vault.getFiles().filter((file) => this.isTemplateFile(file));
    const existingPaths = new Set(templateFiles.map((f) => f.path));
    const cachedPaths = Array.from(this.cache.keys());
    for (const cachedPath of cachedPaths) {
      if (!existingPaths.has(cachedPath)) {
        this.cache.delete(cachedPath);
      }
    }
  }
  removeFromCache(filePath) {
    this.cache.delete(filePath);
  }
  invalidateCache() {
    this.lastScanTime = 0;
  }
  clearCache() {
    this.cache.clear();
    this.lastScanTime = 0;
  }
  updateTemplateFolder(newFolder) {
    if (this.templateFolder !== newFolder) {
      this.templateFolder = newFolder;
      this.clearCache();
    }
  }
  getCacheStats() {
    const entries = Array.from(this.cache.entries()).map(([path, entry]) => {
      const file = this.vault.getAbstractFileByPath(path);
      return {
        path,
        lastModified: entry.lastModified,
        isValid: file ? this.isCacheValid(entry, file) : false
      };
    });
    return {
      size: this.cache.size,
      hitRate: 0,
      // Would need to track hits/misses for accurate calculation
      entries
    };
  }
  // Preload templates for better performance
  async preloadTemplates() {
    const templateFiles = this.vault.getFiles().filter((file) => this.isTemplateFile(file));
    const loadPromises = templateFiles.map((file) => this.getTemplate(file));
    await Promise.allSettled(loadPromises);
    console.log(`Preloaded ${templateFiles.length} templates into cache`);
  }
  // Get template by name (useful for quick lookups)
  async getTemplateByName(name) {
    const templates = await this.getTemplates();
    return templates.find((t) => t.name === name) || null;
  }
  // Get templates by category (from metadata)
  async getTemplatesByCategory(category) {
    const templates = await this.getTemplates();
    return templates.filter((t) => t.metadata.category === category);
  }
  // Get templates by tag
  async getTemplatesByTag(tag) {
    const templates = await this.getTemplates();
    return templates.filter((t) => t.metadata.tags && t.metadata.tags.includes(tag));
  }
  // Search templates by content or metadata
  async searchTemplates(query) {
    const templates = await this.getTemplates();
    const lowerQuery = query.toLowerCase();
    return templates.filter((template) => {
      var _a, _b, _c;
      if (template.name.toLowerCase().includes(lowerQuery)) {
        return true;
      }
      if ((_a = template.metadata.title) == null ? void 0 : _a.toLowerCase().includes(lowerQuery)) {
        return true;
      }
      if ((_b = template.metadata.description) == null ? void 0 : _b.toLowerCase().includes(lowerQuery)) {
        return true;
      }
      if ((_c = template.metadata.tags) == null ? void 0 : _c.some((tag) => tag.toLowerCase().includes(lowerQuery))) {
        return true;
      }
      if (template.body.toLowerCase().includes(lowerQuery)) {
        return true;
      }
      return false;
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  templateFolder: "templates",
  autoMetadata: true,
  gitSync: false,
  publishEnabled: false
};
var AwesomePlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.templateCommandsRegistered = false;
  }
  async onload() {
    await this.loadSettings();
    this.templateCache = new TemplateCache(this.app.vault, this.settings.templateFolder);
    this.addCommand({
      id: "insert-template",
      name: "Insert Template",
      editorCallback: (editor, view) => {
        this.insertTemplate(editor);
      }
    });
    this.addCommand({
      id: "auto-metadata",
      name: "Auto-generate Metadata",
      editorCallback: (editor, view) => {
        this.autoGenerateMetadata(editor, view);
      }
    });
    this.addCommand({
      id: "git-sync",
      name: "Git Sync",
      callback: () => {
        this.gitSync();
      }
    });
    this.addCommand({
      id: "publish-note",
      name: "Publish Note",
      editorCallback: (editor, view) => {
        this.publishNote(view);
      }
    });
    this.addSettingTab(new AwesomePluginSettingTab(this.app, this));
    this.addRibbonIcon("file-plus", "Insert Template", (evt) => {
      this.openTemplateModal();
    });
    this.templateCache.preloadTemplates();
    this.registerTemplateCommands();
  }
  onunload() {
  }
  async openTemplateModal() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!activeView) {
      this.createNewFileWithTemplate();
      return;
    }
    const editor = activeView.editor;
    this.insertTemplate(editor);
  }
  async createNewFileWithTemplate() {
    const templates = await this.getTemplates();
    if (templates.length === 0) {
      new import_obsidian2.Notice("No templates found in templates folder");
      return;
    }
    new TemplateModal(this.app, templates, async (template) => {
      try {
        const newFile = await this.app.vault.create(
          `Untitled-${Date.now()}.md`,
          template.content
        );
        await this.app.workspace.getLeaf().openFile(newFile);
        new import_obsidian2.Notice(`Created new file with template: ${template.name}`);
      } catch (error) {
        new import_obsidian2.Notice(`Failed to create new file: ${error.message}`);
      }
    }).open();
  }
  async registerTemplateCommands() {
    if (this.templateCommandsRegistered) {
      return;
    }
    try {
      const templates = await this.getTemplates();
      for (const template of templates) {
        this.addCommand({
          id: `insert-template-${this.sanitizeId(template.name)}`,
          name: `Insert Template: ${template.name}`,
          editorCallback: (editor, view) => {
            const cursor = editor.getCursor();
            editor.replaceRange(template.content, cursor);
            new import_obsidian2.Notice(`Inserted template: ${template.name}`);
          }
        });
        this.addCommand({
          id: `new-file-template-${this.sanitizeId(template.name)}`,
          name: `New File with Template: ${template.name}`,
          callback: async () => {
            try {
              const newFile = await this.app.vault.create(
                `${template.name}-${Date.now()}.md`,
                template.content
              );
              await this.app.workspace.getLeaf().openFile(newFile);
              new import_obsidian2.Notice(`Created new file with template: ${template.name}`);
            } catch (error) {
              new import_obsidian2.Notice(`Failed to create new file: ${error.message}`);
            }
          }
        });
      }
      this.templateCommandsRegistered = true;
      console.log(`Registered ${templates.length * 2} template commands`);
    } catch (error) {
      console.error("Failed to register template commands:", error);
    }
  }
  sanitizeId(name) {
    return name.toLowerCase().replace(/[^a-z0-9]/g, "-").replace(/-+/g, "-");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.templateCache) {
      this.templateCache.updateTemplateFolder(this.settings.templateFolder);
    }
  }
  async insertTemplate(editor) {
    const templates = await this.getTemplates();
    if (templates.length === 0) {
      new import_obsidian2.Notice("No templates found in templates folder");
      return;
    }
    new TemplateModal(this.app, templates, (template) => {
      const cursor = editor.getCursor();
      editor.replaceRange(template.content, cursor);
      new import_obsidian2.Notice(`Inserted template: ${template.name}`);
    }).open();
  }
  async getTemplates() {
    if (this.templateCache) {
      try {
        const cachedTemplates = await this.templateCache.getTemplates();
        if (cachedTemplates.length === 0) {
          const folder = this.app.vault.getAbstractFileByPath(this.settings.templateFolder);
          if (!folder) {
            new import_obsidian2.Notice(`Template folder '${this.settings.templateFolder}' not found. Using built-in templates.`);
            return this.getDefaultTemplates();
          }
        }
        return cachedTemplates;
      } catch (error) {
        console.error("Failed to load templates from cache:", error);
        new import_obsidian2.Notice("Failed to load templates. Using built-in templates.");
        return this.getDefaultTemplates();
      }
    }
    return this.getTemplatesDirectly();
  }
  async getTemplatesDirectly() {
    const templateFolder = this.settings.templateFolder;
    const vault = this.app.vault;
    try {
      const folder = vault.getAbstractFileByPath(templateFolder);
      if (!folder) {
        new import_obsidian2.Notice(`Template folder '${templateFolder}' not found. Using built-in templates.`);
        return this.getDefaultTemplates();
      }
      const templates = [];
      const files = vault.getFiles().filter((file) => file.path.startsWith(templateFolder) && file.extension === "md");
      for (const file of files) {
        try {
          const content = await vault.read(file);
          const parsedTemplate = TemplateParser.parseTemplate(file.basename, content, file.path);
          if (!parsedTemplate.isValid) {
            console.warn(`Template validation failed for ${file.path}:`, parsedTemplate.errors);
            new import_obsidian2.Notice(
              `Template validation warnings in ${file.basename}: ${parsedTemplate.errors.join(
                ", "
              )}`
            );
          }
          templates.push(parsedTemplate);
        } catch (error) {
          console.warn(`Failed to read template file: ${file.path}`, error);
        }
      }
      return templates;
    } catch (error) {
      console.error("Failed to load templates from folder:", error);
      new import_obsidian2.Notice("Failed to load templates from folder. Using built-in templates.");
      return this.getDefaultTemplates();
    }
  }
  /**
   * Fallback templates used only when template folder doesn't exist or loading fails
   * These are minimal built-in templates to ensure the plugin always works
   */
  getDefaultTemplates() {
    console.log("Using built-in fallback templates");
    const defaultTemplates = [
      {
        name: "Daily Note",
        content: `---
title: Daily Note Template
description: A template for daily notes with tasks and reflection
category: daily
tags: [daily, tasks, reflection]
variables: [date]
---

# {{date}}

## Tasks
- [ ] 

## Notes

## Reflection
`,
        path: "built-in/daily-note.md"
      },
      {
        name: "Meeting Notes",
        content: `---
title: Meeting Notes Template
description: A template for meeting notes with agenda and action items
category: meeting
tags: [meeting, notes, action-items]
variables: [title, date]
---

# Meeting: {{title}}

**Date:** {{date}}
**Attendees:** 

## Agenda

## Notes

## Action Items
- [ ] 
`,
        path: "built-in/meeting-notes.md"
      }
    ];
    return defaultTemplates.map(
      (template) => TemplateParser.parseTemplate(template.name, template.content, template.path)
    );
  }
  autoGenerateMetadata(editor, view) {
    if (!this.settings.autoMetadata) {
      new import_obsidian2.Notice("Auto metadata is disabled in settings");
      return;
    }
    const file = view.file;
    if (!file)
      return;
    const metadata = {
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString(),
      tags: [],
      title: file.basename
    };
    const frontmatter = `---
${Object.entries(metadata).map(([key, value]) => `${key}: ${Array.isArray(value) ? "[]" : value}`).join("\n")}
---

`;
    const content = editor.getValue();
    if (!content.startsWith("---")) {
      editor.setValue(frontmatter + content);
      new import_obsidian2.Notice("Metadata added");
    }
  }
  async gitSync() {
    if (!this.settings.gitSync) {
      new import_obsidian2.Notice("Git sync is disabled in settings");
      return;
    }
    new import_obsidian2.Notice("Git sync feature coming soon...");
  }
  publishNote(view) {
    if (!this.settings.publishEnabled) {
      new import_obsidian2.Notice("Publishing is disabled in settings");
      return;
    }
    new import_obsidian2.Notice("Publish feature coming soon...");
  }
};
var TemplateModal = class extends import_obsidian2.Modal {
  constructor(app, templates, onChoose) {
    super(app);
    this.templates = templates;
    this.onChoose = onChoose;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Choose Template" });
    this.templates.forEach((template) => {
      const templateEl = contentEl.createEl("div", { cls: "template-item" });
      if (!template.isValid) {
        templateEl.style.border = "1px solid var(--text-error)";
        templateEl.style.borderRadius = "4px";
        templateEl.style.padding = "8px";
        templateEl.style.marginBottom = "8px";
      }
      const headerEl = templateEl.createEl("div", { cls: "template-header" });
      const button = headerEl.createEl("button", {
        text: template.name,
        cls: "mod-cta"
      });
      if (!template.isValid) {
        const warningEl = headerEl.createEl("span", {
          text: " \u26A0\uFE0F",
          cls: "template-warning"
        });
        warningEl.title = template.errors.join("; ");
      }
      if (template.metadata.description) {
        const descEl = templateEl.createEl("div", {
          text: template.metadata.description,
          cls: "template-description"
        });
        descEl.style.fontSize = "0.85em";
        descEl.style.color = "var(--text-muted)";
        descEl.style.marginTop = "2px";
      }
      if (template.variables.length > 0) {
        const varsEl = templateEl.createEl("div", {
          text: `Variables: ${template.variables.join(", ")}`,
          cls: "template-variables"
        });
        varsEl.style.fontSize = "0.8em";
        varsEl.style.color = "var(--text-accent)";
        varsEl.style.marginTop = "2px";
      }
      const pathEl = templateEl.createEl("div", {
        text: template.path.startsWith("built-in/") ? "Built-in template" : template.path,
        cls: "template-path"
      });
      pathEl.style.fontSize = "0.8em";
      pathEl.style.color = "var(--text-muted)";
      pathEl.style.marginTop = "4px";
      button.onclick = () => {
        this.onChoose(template);
        this.close();
      };
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AwesomePluginSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Awesome Plugin Settings" });
    new import_obsidian2.Setting(containerEl).setName("Template Folder").setDesc("Folder to look for template files (.md files with frontmatter)").addText(
      (text) => text.setPlaceholder("templates").setValue(this.plugin.settings.templateFolder).onChange(async (value) => {
        this.plugin.settings.templateFolder = value;
        await this.plugin.saveSettings();
      })
    ).addButton(
      (button) => button.setButtonText("Create Folder").setTooltip("Create the template folder if it doesn't exist").onClick(async () => {
        try {
          const folderPath = this.plugin.settings.templateFolder;
          const folder = this.plugin.app.vault.getAbstractFileByPath(folderPath);
          if (!folder) {
            await this.plugin.app.vault.createFolder(folderPath);
            new import_obsidian2.Notice(`Created template folder: ${folderPath}`);
          } else {
            new import_obsidian2.Notice(`Template folder already exists: ${folderPath}`);
          }
        } catch (error) {
          new import_obsidian2.Notice(`Failed to create template folder: ${error.message}`);
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Auto Metadata").setDesc("Automatically generate frontmatter metadata").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoMetadata).onChange(async (value) => {
        this.plugin.settings.autoMetadata = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Git Sync").setDesc("Enable git synchronization features").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.gitSync).onChange(async (value) => {
        this.plugin.settings.gitSync = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Publishing").setDesc("Enable publishing to static sites").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.publishEnabled).onChange(async (value) => {
        this.plugin.settings.publishEnabled = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
