/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GitSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/git-service.ts
var import_simple_git = require("simple-git");
var GitService = class {
  constructor(repoPath) {
    this.repoPath = repoPath;
    this.git = (0, import_simple_git.simpleGit)(repoPath);
  }
  /**
   * Get the current git status
   */
  async getStatus() {
    try {
      const status = await this.git.status();
      const branch = await this.git.revparse(["--abbrev-ref", "HEAD"]);
      let ahead = 0;
      let behind = 0;
      try {
        const aheadBehind = await this.git.raw(["rev-list", "--left-right", "--count", `origin/${branch.trim()}...HEAD`]);
        const counts = aheadBehind.trim().split("	");
        behind = parseInt(counts[0]) || 0;
        ahead = parseInt(counts[1]) || 0;
      } catch (error) {
        console.warn("Could not get ahead/behind info:", error);
      }
      return {
        hasChanges: status.files.length > 0,
        staged: status.staged,
        unstaged: status.modified.concat(status.deleted),
        untracked: status.not_added,
        currentBranch: branch.trim(),
        ahead,
        behind
      };
    } catch (error) {
      console.error("Failed to get git status:", error);
      throw error;
    }
  }
  /**
   * Add files to staging area
   */
  async addFiles(files = ".", includeUntracked = true) {
    try {
      if (includeUntracked && files === ".") {
        await this.git.add(".");
      } else if (Array.isArray(files)) {
        await this.git.add(files);
      } else {
        await this.git.add([files]);
      }
      return { success: true };
    } catch (error) {
      console.error("Failed to add files:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Commit staged changes
   */
  async commit(message) {
    try {
      const result = await this.git.commit(message);
      return {
        success: true,
        data: {
          hash: result.commit,
          summary: result.summary
        }
      };
    } catch (error) {
      console.error("Failed to commit:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Add and commit in one operation
   */
  async addAndCommit(message, includeUntracked = true) {
    try {
      const status = await this.getStatus();
      if (!status.hasChanges) {
        return { success: true, data: { message: "No changes to commit" } };
      }
      const addResult = await this.addFiles(".", includeUntracked);
      if (!addResult.success) {
        return addResult;
      }
      const commitResult = await this.commit(message);
      return commitResult;
    } catch (error) {
      console.error("Failed to add and commit:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Push commits to remote
   */
  async push(branch) {
    try {
      if (branch) {
        await this.git.push("origin", branch);
      } else {
        await this.git.push();
      }
      return { success: true };
    } catch (error) {
      console.error("Failed to push:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Pull with rebase
   */
  async pullRebase(branch) {
    try {
      const result = await this.git.pull("origin", branch, { "--rebase": "true" });
      const status = await this.getStatus();
      const hasConflicts = status.unstaged.some(
        (file) => file.includes("<<<<<<< HEAD") || file.includes(">>>>>>> ")
      );
      return {
        success: true,
        conflicts: hasConflicts,
        data: result
      };
    } catch (error) {
      console.error("Failed to pull with rebase:", error);
      const isConflict = error.message.includes("conflict") || error.message.includes("CONFLICT");
      if (isConflict) {
        return { success: true, conflicts: true, error: error.message };
      }
      return { success: false, error: error.message };
    }
  }
  /**
   * Switch to a branch (create if it doesn't exist)
   */
  async switchBranch(branchName, createIfNotExists = true) {
    try {
      const branches = await this.git.branchLocal();
      const branchExists = branches.all.includes(branchName);
      if (!branchExists && createIfNotExists) {
        await this.git.checkoutLocalBranch(branchName);
      } else if (branchExists) {
        await this.git.checkout(branchName);
      } else {
        return { success: false, error: `Branch ${branchName} does not exist` };
      }
      return { success: true };
    } catch (error) {
      console.error("Failed to switch branch:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Merge branches
   */
  async mergeBranches(fromBranch, toBranch, strategy = "merge") {
    try {
      const switchResult = await this.switchBranch(toBranch);
      if (!switchResult.success) {
        return switchResult;
      }
      let result;
      switch (strategy) {
        case "rebase":
          result = await this.git.rebase([fromBranch]);
          break;
        case "squash":
          result = await this.git.merge([fromBranch, "--squash"]);
          const status2 = await this.getStatus();
          if (status2.staged.length > 0) {
            await this.commit(`Squash merge ${fromBranch} into ${toBranch}`);
          }
          break;
        default:
          result = await this.git.merge([fromBranch]);
          break;
      }
      const status = await this.getStatus();
      const hasConflicts = status.unstaged.length > 0;
      return {
        success: true,
        conflicts: hasConflicts,
        data: result
      };
    } catch (error) {
      console.error("Failed to merge branches:", error);
      const isConflict = error.message.includes("conflict") || error.message.includes("CONFLICT");
      if (isConflict) {
        return { success: true, conflicts: true, error: error.message };
      }
      return { success: false, error: error.message };
    }
  }
  /**
   * Get current branch name
   */
  async getCurrentBranch() {
    try {
      const branch = await this.git.revparse(["--abbrev-ref", "HEAD"]);
      return branch.trim();
    } catch (error) {
      console.error("Failed to get current branch:", error);
      return "unknown";
    }
  }
  /**
   * Check if repository is clean (no uncommitted changes)
   */
  async isClean() {
    try {
      const status = await this.getStatus();
      return !status.hasChanges;
    } catch (error) {
      console.error("Failed to check if repo is clean:", error);
      return false;
    }
  }
  /**
   * Get list of recent commits
   */
  async getRecentCommits(count = 10) {
    try {
      const log = await this.git.log({ maxCount: count });
      return [...log.all];
    } catch (error) {
      console.error("Failed to get recent commits:", error);
      return [];
    }
  }
  /**
   * Check if remote repository is available
   */
  async checkRemoteConnection() {
    try {
      await this.git.listRemote(["--heads"]);
      return true;
    } catch (error) {
      console.warn("Remote connection check failed:", error);
      return false;
    }
  }
  /**
   * Initialize git repository if not already initialized
   */
  async initIfNeeded() {
    try {
      const isRepo = await this.git.checkIsRepo();
      if (!isRepo) {
        await this.git.init();
        return { success: true, data: { message: "Repository initialized" } };
      }
      return { success: true, data: { message: "Repository already exists" } };
    } catch (error) {
      console.error("Failed to initialize repository:", error);
      return { success: false, error: error.message };
    }
  }
};

// src/llm-service.ts
var LLMService = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Generate commit message using LLM
   */
  async generateCommitMessage(context) {
    if (!this.settings.enabled || this.settings.provider === "none") {
      return {
        success: false,
        error: "LLM service is disabled"
      };
    }
    if (!this.settings.apiKey) {
      return {
        success: false,
        error: "API key is not configured"
      };
    }
    try {
      switch (this.settings.provider) {
        case "openai":
          return await this.generateWithOpenAI(context);
        case "anthropic":
          return await this.generateWithAnthropic(context);
        default:
          return {
            success: false,
            error: `Unsupported provider: ${this.settings.provider}`
          };
      }
    } catch (error) {
      console.error("LLM commit message generation failed:", error);
      return {
        success: false,
        error: error.message || "Unknown error occurred"
      };
    }
  }
  /**
   * Generate commit message using OpenAI GPT
   */
  async generateWithOpenAI(context) {
    var _a, _b, _c, _d, _e;
    const prompt = this.buildPrompt(context);
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.settings.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "system",
            content: "You are a helpful assistant that generates concise, conventional commit messages based on git changes. Follow conventional commits format (type(scope): description). Keep it under 50 characters for the subject line."
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: 100,
        temperature: 0.3
      })
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`OpenAI API error: ${response.status} ${((_a = errorData.error) == null ? void 0 : _a.message) || response.statusText}`);
    }
    const data = await response.json();
    const message = (_e = (_d = (_c = (_b = data.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content) == null ? void 0 : _e.trim();
    if (!message) {
      throw new Error("No message generated from OpenAI API");
    }
    return {
      success: true,
      message: this.cleanupMessage(message)
    };
  }
  /**
   * Generate commit message using Anthropic Claude
   */
  async generateWithAnthropic(context) {
    var _a, _b, _c, _d;
    const prompt = this.buildPrompt(context);
    const response = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.settings.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: "claude-3-haiku-20240307",
        max_tokens: 100,
        messages: [
          {
            role: "user",
            content: `You are a helpful assistant that generates concise, conventional commit messages based on git changes. Follow conventional commits format (type(scope): description). Keep it under 50 characters for the subject line.

${prompt}`
          }
        ]
      })
    });
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Anthropic API error: ${response.status} ${((_a = errorData.error) == null ? void 0 : _a.message) || response.statusText}`);
    }
    const data = await response.json();
    const message = (_d = (_c = (_b = data.content) == null ? void 0 : _b[0]) == null ? void 0 : _c.text) == null ? void 0 : _d.trim();
    if (!message) {
      throw new Error("No message generated from Anthropic API");
    }
    return {
      success: true,
      message: this.cleanupMessage(message)
    };
  }
  /**
   * Build prompt for LLM based on git context
   */
  buildPrompt(context) {
    const { files, diff, recentCommits, branch } = context;
    let prompt = this.settings.commitPrompt || "Generate a concise commit message for these changes:";
    prompt += "\n\n";
    const totalFiles = files.staged.length + files.unstaged.length + files.untracked.length;
    prompt += `Files changed (${totalFiles} total):
`;
    if (files.staged.length > 0) {
      prompt += `Staged: ${files.staged.slice(0, 5).join(", ")}${files.staged.length > 5 ? ` and ${files.staged.length - 5} more` : ""}
`;
    }
    if (files.unstaged.length > 0) {
      prompt += `Modified: ${files.unstaged.slice(0, 5).join(", ")}${files.unstaged.length > 5 ? ` and ${files.unstaged.length - 5} more` : ""}
`;
    }
    if (files.untracked.length > 0) {
      prompt += `New: ${files.untracked.slice(0, 5).join(", ")}${files.untracked.length > 5 ? ` and ${files.untracked.length - 5} more` : ""}
`;
    }
    prompt += `
Branch: ${branch}
`;
    if (diff && diff.length > 0) {
      const truncatedDiff = diff.length > 1e3 ? diff.substring(0, 1e3) + "..." : diff;
      prompt += `
Changes:
${truncatedDiff}
`;
    }
    if (recentCommits && recentCommits.length > 0) {
      prompt += `
Recent commits for context:
${recentCommits.slice(0, 3).join("\n")}
`;
    }
    prompt += "\nGenerate a conventional commit message (type(scope): description) that is concise and descriptive.";
    return prompt;
  }
  /**
   * Clean up and validate generated commit message
   */
  cleanupMessage(message) {
    let cleaned = message.replace(/^["']|["']$/g, "");
    cleaned = cleaned.replace(/`/g, "");
    cleaned = cleaned.replace(/^(commit:?\s*|message:?\s*)/i, "");
    const lines = cleaned.split("\n");
    let subject = lines[0].trim();
    if (!subject.match(/^(feat|fix|docs|style|refactor|test|chore|perf|ci|build)(\(.+\))?: .+/)) {
      if (subject.includes("test") || subject.includes("spec")) {
        subject = `test: ${subject}`;
      } else if (subject.includes("doc") || subject.includes("readme")) {
        subject = `docs: ${subject}`;
      } else if (subject.includes("fix") || subject.includes("bug")) {
        subject = `fix: ${subject}`;
      } else if (subject.includes("add") || subject.includes("new")) {
        subject = `feat: ${subject}`;
      } else {
        subject = `chore: ${subject}`;
      }
    }
    subject = subject.replace(/^(\w+(?:\(.+\))?):\s*([A-Z])/, (match, prefix, firstChar) => {
      return `${prefix}: ${firstChar.toLowerCase()}`;
    });
    if (subject.length > 50) {
      subject = subject.substring(0, 47) + "...";
    }
    if (lines.length > 1) {
      const body = lines.slice(1).join("\n").trim();
      if (body) {
        return `${subject}

${body}`;
      }
    }
    return subject;
  }
  /**
   * Test API connection
   */
  async testConnection() {
    if (!this.settings.apiKey) {
      return {
        success: false,
        error: "API key is not configured"
      };
    }
    const testContext = {
      files: {
        staged: ["test.md"],
        unstaged: [],
        untracked: []
      },
      branch: "test"
    };
    try {
      const result = await this.generateCommitMessage(testContext);
      if (result.success) {
        return {
          success: true,
          message: "API connection successful"
        };
      } else {
        return result;
      }
    } catch (error) {
      return {
        success: false,
        error: `Connection test failed: ${error.message}`
      };
    }
  }
  /**
   * Get available models for the current provider
   */
  getAvailableModels() {
    switch (this.settings.provider) {
      case "openai":
        return ["gpt-3.5-turbo", "gpt-4", "gpt-4-turbo-preview"];
      case "anthropic":
        return ["claude-3-haiku-20240307", "claude-3-sonnet-20240229", "claude-3-opus-20240229"];
      default:
        return [];
    }
  }
  /**
   * Estimate token usage for a prompt
   */
  estimateTokens(context) {
    const prompt = this.buildPrompt(context);
    return Math.ceil(prompt.length / 4);
  }
};

// src/auto-commit-service.ts
var AutoCommitService = class {
  constructor(gitService, settings, vault) {
    this.intervalId = null;
    this.commitCount = 0;
    this.lastCommitTime = 0;
    this.gitService = gitService;
    this.settings = settings;
    this.vault = vault;
    this.llmService = new LLMService({
      provider: settings.llmProvider,
      apiKey: settings.apiKey,
      commitPrompt: settings.commitPrompt,
      enabled: settings.enableAICommitMessages
    });
  }
  /**
   * Start the auto commit service
   */
  start() {
    if (this.intervalId) {
      this.stop();
    }
    if (!this.settings.enableAutoCommit) {
      return;
    }
    const intervalMs = this.settings.commitIntervalMinutes * 60 * 1e3;
    this.intervalId = setInterval(() => {
      this.performAutoCommit();
    }, intervalMs);
    console.log(`Auto commit service started with ${this.settings.commitIntervalMinutes} minute interval`);
  }
  /**
   * Stop the auto commit service
   */
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      console.log("Auto commit service stopped");
    }
  }
  /**
   * Update settings and restart if needed
   */
  updateSettings(settings) {
    this.settings = settings;
    this.llmService.updateSettings({
      provider: settings.llmProvider,
      apiKey: settings.apiKey,
      commitPrompt: settings.commitPrompt,
      enabled: settings.enableAICommitMessages
    });
    if (this.settings.enableAutoCommit) {
      this.start();
    } else {
      this.stop();
    }
  }
  /**
   * Perform an automatic commit
   */
  async performAutoCommit() {
    var _a;
    try {
      console.log("Starting auto commit...");
      const currentBranch = await this.gitService.getCurrentBranch();
      if (currentBranch !== this.settings.tempBranch) {
        const switchResult = await this.gitService.switchBranch(this.settings.tempBranch);
        if (!switchResult.success) {
          return {
            success: false,
            error: `Failed to switch to ${this.settings.tempBranch}: ${switchResult.error}`
          };
        }
      }
      const status = await this.gitService.getStatus();
      if (!status.hasChanges) {
        console.log("No changes to commit");
        return {
          success: true,
          message: "No changes to commit"
        };
      }
      const commitMessage = await this.generateCommitMessage(status);
      const commitResult = await this.gitService.addAndCommit(
        commitMessage,
        this.settings.includeUntracked
      );
      if (!commitResult.success) {
        return {
          success: false,
          error: commitResult.error
        };
      }
      this.commitCount++;
      this.lastCommitTime = Date.now();
      console.log(`Auto commit successful: ${commitMessage}`);
      let pushResult = null;
      if (this.settings.enableAutoPush && this.commitCount >= this.settings.pushAfterCommits) {
        pushResult = await this.gitService.push(this.settings.tempBranch);
        if (pushResult.success) {
          this.commitCount = 0;
          console.log("Auto push successful");
        } else {
          console.warn("Auto push failed:", pushResult.error);
        }
      }
      return {
        success: true,
        message: commitMessage,
        filesChanged: status.staged.length + status.unstaged.length + status.untracked.length,
        hash: (_a = commitResult.data) == null ? void 0 : _a.hash
      };
    } catch (error) {
      console.error("Auto commit failed:", error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  /**
   * Perform a manual commit (can be called from command)
   */
  async performCommit() {
    return this.performAutoCommit();
  }
  /**
   * Generate a commit message based on changes
   */
  async generateCommitMessage(status) {
    if (this.settings.enableAICommitMessages) {
      try {
        const commitContext = {
          files: {
            staged: status.staged || [],
            unstaged: status.unstaged || [],
            untracked: status.untracked || []
          },
          branch: status.currentBranch || "unknown"
        };
        try {
          const recentCommits = await this.gitService.getRecentCommits(3);
          commitContext.recentCommits = recentCommits.map(
            (commit) => {
              var _a;
              return `${((_a = commit.hash) == null ? void 0 : _a.substring(0, 7)) || "unknown"}: ${commit.message || "no message"}`;
            }
          );
        } catch (error) {
          console.warn("Failed to get recent commits for context:", error);
        }
        const llmResult = await this.llmService.generateCommitMessage(commitContext);
        if (llmResult.success && llmResult.message) {
          console.log("Generated commit message using LLM:", llmResult.message);
          return llmResult.message;
        } else {
          console.warn("LLM commit message generation failed:", llmResult.error);
        }
      } catch (error) {
        console.warn("LLM commit message generation error:", error);
      }
    }
    return this.generateFallbackCommitMessage(status);
  }
  /**
   * Generate fallback commit message (original logic)
   */
  generateFallbackCommitMessage(status) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ");
    const totalChanges = status.staged.length + status.unstaged.length + status.untracked.length;
    if (totalChanges === 0) {
      return `chore: auto commit at ${timestamp}`;
    }
    const categories = {
      added: status.untracked.length,
      modified: status.unstaged.filter((f) => !f.includes("deleted")).length,
      deleted: status.unstaged.filter((f) => f.includes("deleted")).length,
      staged: status.staged.length
    };
    const parts = [];
    if (categories.added > 0) {
      parts.push(`${categories.added} added`);
    }
    if (categories.modified > 0) {
      parts.push(`${categories.modified} modified`);
    }
    if (categories.deleted > 0) {
      parts.push(`${categories.deleted} deleted`);
    }
    let description = parts.join(", ");
    if (!description) {
      description = `${totalChanges} changes`;
    }
    const allFiles = [...status.staged, ...status.unstaged, ...status.untracked];
    const hasMarkdown = allFiles.some((f) => f.endsWith(".md"));
    const hasAttachments = allFiles.some(
      (f) => f.endsWith(".png") || f.endsWith(".jpg") || f.endsWith(".jpeg") || f.endsWith(".gif") || f.endsWith(".pdf")
    );
    const hasConfigs = allFiles.some(
      (f) => f.endsWith(".json") || f.endsWith(".yaml") || f.endsWith(".yml")
    );
    let prefix = "docs";
    if (hasMarkdown && !hasAttachments && !hasConfigs) {
      prefix = "docs";
    } else if (hasAttachments) {
      prefix = "assets";
    } else if (hasConfigs) {
      prefix = "config";
    } else {
      prefix = "update";
    }
    return `${prefix}: auto commit - ${description}

Auto-committed at ${timestamp}`;
  }
  /**
   * Get current commit count since last push
   */
  getCommitCount() {
    return this.commitCount;
  }
  /**
   * Get last commit time
   */
  getLastCommitTime() {
    return this.lastCommitTime;
  }
  /**
   * Reset commit counter (useful after manual push)
   */
  resetCommitCount() {
    this.commitCount = 0;
  }
  /**
   * Check if auto commit is due based on file modification times
   */
  async isCommitDue() {
    if (!this.settings.enableAutoCommit) {
      return false;
    }
    const now = Date.now();
    const intervalMs = this.settings.commitIntervalMinutes * 60 * 1e3;
    const timeSinceLastCommit = now - this.lastCommitTime;
    if (timeSinceLastCommit < intervalMs) {
      return false;
    }
    const status = await this.gitService.getStatus();
    return status.hasChanges;
  }
  /**
   * Get a summary of pending changes
   */
  async getPendingChangesSummary() {
    try {
      const status = await this.gitService.getStatus();
      return {
        hasChanges: status.hasChanges,
        totalFiles: status.staged.length + status.unstaged.length + status.untracked.length,
        added: status.staged.length,
        modified: status.unstaged.filter((f) => !f.includes("deleted")).length,
        deleted: status.unstaged.filter((f) => f.includes("deleted")).length,
        untracked: status.untracked.length
      };
    } catch (error) {
      console.error("Failed to get pending changes summary:", error);
      return {
        hasChanges: false,
        totalFiles: 0,
        added: 0,
        modified: 0,
        deleted: 0,
        untracked: 0
      };
    }
  }
  /**
   * Test LLM API connection
   */
  async testLLMConnection() {
    try {
      return await this.llmService.testConnection();
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  /**
   * Get available LLM models
   */
  getAvailableLLMModels() {
    return this.llmService.getAvailableModels();
  }
  /**
   * Estimate tokens for current changes
   */
  async estimateTokensForCurrentChanges() {
    try {
      const status = await this.gitService.getStatus();
      const context = {
        files: {
          staged: status.staged || [],
          unstaged: status.unstaged || [],
          untracked: status.untracked || []
        },
        branch: status.currentBranch || "unknown"
      };
      return this.llmService.estimateTokens(context);
    } catch (error) {
      console.error("Failed to estimate tokens:", error);
      return 0;
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  // Branch settings
  tempBranch: "tmp",
  mainBranch: "main",
  // Auto commit settings
  enableAutoCommit: false,
  commitIntervalMinutes: 10,
  includeUntracked: true,
  // Auto push settings
  enableAutoPush: false,
  pushAfterCommits: 3,
  // LLM settings
  enableAICommitMessages: false,
  llmProvider: "none",
  apiKey: "",
  commitPrompt: "Generate a concise commit message for these changes:",
  // Auto pull settings
  enableAutoPull: false,
  pullOnStartup: true,
  // Merge settings
  enableAutoMerge: false,
  mergeStrategy: "merge",
  // Conflict resolution
  openEditorOnConflict: true,
  editorCommand: "code ."
};
var GitSyncPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.gitService = new GitService(this.app.vault.adapter.basePath || "");
    this.autoCommitService = new AutoCommitService(
      this.gitService,
      this.settings,
      this.app.vault
    );
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar("Git Sync Ready");
    this.addCommand({
      id: "manual-commit",
      name: "Manual Commit",
      callback: () => this.manualCommit()
    });
    this.addCommand({
      id: "manual-push",
      name: "Manual Push",
      callback: () => this.manualPush()
    });
    this.addCommand({
      id: "manual-pull",
      name: "Manual Pull",
      callback: () => this.manualPull()
    });
    this.addCommand({
      id: "switch-to-temp-branch",
      name: "Switch to Temp Branch",
      callback: () => this.switchToTempBranch()
    });
    this.addCommand({
      id: "merge-temp-to-main",
      name: "Merge Temp to Main",
      callback: () => this.mergeTempToMain()
    });
    this.addCommand({
      id: "toggle-auto-commit",
      name: "Toggle Auto Commit",
      callback: () => this.toggleAutoCommit()
    });
    this.addCommand({
      id: "test-llm-connection",
      name: "Test LLM API Connection",
      callback: () => this.testLLMConnection()
    });
    this.addCommand({
      id: "generate-ai-commit-message",
      name: "Generate AI Commit Message",
      callback: () => this.generateAICommitMessage()
    });
    this.addSettingTab(new GitSyncSettingTab(this.app, this));
    if (this.settings.enableAutoPull && this.settings.pullOnStartup) {
      this.performAutoPull();
    }
    if (this.settings.enableAutoCommit) {
      this.autoCommitService.start();
    }
    console.log("Git Sync plugin loaded");
  }
  onunload() {
    var _a;
    (_a = this.autoCommitService) == null ? void 0 : _a.stop();
    console.log("Git Sync plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.autoCommitService) {
      this.autoCommitService.updateSettings(this.settings);
      if (this.settings.enableAutoCommit) {
        this.autoCommitService.start();
      } else {
        this.autoCommitService.stop();
      }
    }
  }
  updateStatusBar(text) {
    this.statusBarItem.setText(`Git: ${text}`);
  }
  async manualCommit() {
    try {
      this.updateStatusBar("Committing...");
      const result = await this.autoCommitService.performCommit();
      if (result.success) {
        new import_obsidian.Notice(`Committed: ${result.message}`);
        this.updateStatusBar("Commit successful");
      } else {
        new import_obsidian.Notice(`Commit failed: ${result.error}`);
        this.updateStatusBar("Commit failed");
      }
    } catch (error) {
      console.error("Manual commit error:", error);
      new import_obsidian.Notice(`Commit error: ${error.message}`);
      this.updateStatusBar("Commit error");
    }
  }
  async manualPush() {
    try {
      this.updateStatusBar("Pushing...");
      const result = await this.gitService.push();
      if (result.success) {
        new import_obsidian.Notice("Push successful");
        this.updateStatusBar("Push successful");
      } else {
        new import_obsidian.Notice(`Push failed: ${result.error}`);
        this.updateStatusBar("Push failed");
      }
    } catch (error) {
      console.error("Manual push error:", error);
      new import_obsidian.Notice(`Push error: ${error.message}`);
      this.updateStatusBar("Push error");
    }
  }
  async manualPull() {
    try {
      this.updateStatusBar("Pulling...");
      await this.performAutoPull();
    } catch (error) {
      console.error("Manual pull error:", error);
      new import_obsidian.Notice(`Pull error: ${error.message}`);
      this.updateStatusBar("Pull error");
    }
  }
  async performAutoPull() {
    try {
      const result = await this.gitService.pullRebase();
      if (result.success) {
        new import_obsidian.Notice("Pull successful");
        this.updateStatusBar("Pull successful");
      } else if (result.conflicts) {
        new import_obsidian.Notice("Pull completed with conflicts - please resolve manually");
        this.updateStatusBar("Conflicts detected");
        if (this.settings.openEditorOnConflict) {
          this.openExternalEditor();
        }
      } else {
        new import_obsidian.Notice(`Pull failed: ${result.error}`);
        this.updateStatusBar("Pull failed");
      }
    } catch (error) {
      console.error("Auto pull error:", error);
      new import_obsidian.Notice(`Pull error: ${error.message}`);
      this.updateStatusBar("Pull error");
    }
  }
  async switchToTempBranch() {
    try {
      this.updateStatusBar("Switching branch...");
      const result = await this.gitService.switchBranch(this.settings.tempBranch);
      if (result.success) {
        new import_obsidian.Notice(`Switched to ${this.settings.tempBranch} branch`);
        this.updateStatusBar(`On ${this.settings.tempBranch}`);
      } else {
        new import_obsidian.Notice(`Failed to switch branch: ${result.error}`);
        this.updateStatusBar("Branch switch failed");
      }
    } catch (error) {
      console.error("Switch branch error:", error);
      new import_obsidian.Notice(`Branch switch error: ${error.message}`);
      this.updateStatusBar("Branch switch error");
    }
  }
  async mergeTempToMain() {
    try {
      this.updateStatusBar("Merging...");
      const result = await this.gitService.mergeBranches(
        this.settings.tempBranch,
        this.settings.mainBranch,
        this.settings.mergeStrategy
      );
      if (result.success) {
        new import_obsidian.Notice(`Merged ${this.settings.tempBranch} to ${this.settings.mainBranch}`);
        this.updateStatusBar("Merge successful");
      } else if (result.conflicts) {
        new import_obsidian.Notice("Merge completed with conflicts - please resolve manually");
        this.updateStatusBar("Merge conflicts");
        if (this.settings.openEditorOnConflict) {
          this.openExternalEditor();
        }
      } else {
        new import_obsidian.Notice(`Merge failed: ${result.error}`);
        this.updateStatusBar("Merge failed");
      }
    } catch (error) {
      console.error("Merge error:", error);
      new import_obsidian.Notice(`Merge error: ${error.message}`);
      this.updateStatusBar("Merge error");
    }
  }
  toggleAutoCommit() {
    this.settings.enableAutoCommit = !this.settings.enableAutoCommit;
    this.saveSettings();
    const status = this.settings.enableAutoCommit ? "enabled" : "disabled";
    new import_obsidian.Notice(`Auto commit ${status}`);
    this.updateStatusBar(`Auto commit ${status}`);
  }
  openExternalEditor() {
    try {
      const { exec } = require("child_process");
      exec(this.settings.editorCommand, { cwd: this.app.vault.adapter.basePath || "" });
    } catch (error) {
      console.error("Failed to open external editor:", error);
      new import_obsidian.Notice("Failed to open external editor");
    }
  }
  async testLLMConnection() {
    try {
      this.updateStatusBar("Testing LLM...");
      const result = await this.autoCommitService.testLLMConnection();
      if (result.success) {
        new import_obsidian.Notice("LLM API connection successful");
        this.updateStatusBar("LLM test successful");
      } else {
        new import_obsidian.Notice(`LLM API test failed: ${result.error}`);
        this.updateStatusBar("LLM test failed");
      }
    } catch (error) {
      console.error("LLM connection test error:", error);
      new import_obsidian.Notice(`LLM test error: ${error.message}`);
      this.updateStatusBar("LLM test error");
    }
  }
  async generateAICommitMessage() {
    try {
      this.updateStatusBar("Generating AI commit...");
      const status = await this.gitService.getStatus();
      if (!status.hasChanges) {
        new import_obsidian.Notice("No changes to commit");
        this.updateStatusBar("No changes");
        return;
      }
      if (!this.settings.enableAICommitMessages) {
        new import_obsidian.Notice("AI commit messages are disabled. Enable in settings first.");
        this.updateStatusBar("AI commits disabled");
        return;
      }
      const result = await this.autoCommitService.performCommit();
      if (result.success) {
        new import_obsidian.Notice(`AI commit successful: ${result.message || "Committed"}`);
        this.updateStatusBar("AI commit successful");
      } else {
        new import_obsidian.Notice(`AI commit failed: ${result.error}`);
        this.updateStatusBar("AI commit failed");
      }
    } catch (error) {
      console.error("AI commit generation error:", error);
      new import_obsidian.Notice(`AI commit error: ${error.message}`);
      this.updateStatusBar("AI commit error");
    }
  }
};
var GitSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Git Sync Settings" });
    containerEl.createEl("h3", { text: "Branch Settings" });
    new import_obsidian.Setting(containerEl).setName("Temp Branch Name").setDesc("Name of the temporary branch for auto commits").addText((text) => text.setPlaceholder("tmp").setValue(this.plugin.settings.tempBranch).onChange(async (value) => {
      this.plugin.settings.tempBranch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Main Branch Name").setDesc("Name of the main branch to merge into").addText((text) => text.setPlaceholder("main").setValue(this.plugin.settings.mainBranch).onChange(async (value) => {
      this.plugin.settings.mainBranch = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto Commit Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Auto Commit").setDesc("Automatically commit changes at regular intervals").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoCommit).onChange(async (value) => {
      this.plugin.settings.enableAutoCommit = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Commit Interval (minutes)").setDesc("How often to commit changes").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.commitIntervalMinutes).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.commitIntervalMinutes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include Untracked Files").setDesc("Include new files in auto commits").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeUntracked).onChange(async (value) => {
      this.plugin.settings.includeUntracked = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto Push Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Auto Push").setDesc("Automatically push commits to remote").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoPush).onChange(async (value) => {
      this.plugin.settings.enableAutoPush = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Push After Commits").setDesc("Number of commits before auto pushing").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.pushAfterCommits).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.pushAfterCommits = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto Pull Settings" });
    new import_obsidian.Setting(containerEl).setName("Pull on Startup").setDesc("Automatically pull latest changes when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.pullOnStartup).onChange(async (value) => {
      this.plugin.settings.pullOnStartup = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Merge Settings" });
    new import_obsidian.Setting(containerEl).setName("Merge Strategy").setDesc("How to merge temp branch into main").addDropdown((dropdown) => dropdown.addOption("merge", "Merge").addOption("rebase", "Rebase").addOption("squash", "Squash").setValue(this.plugin.settings.mergeStrategy).onChange(async (value) => {
      this.plugin.settings.mergeStrategy = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Conflict Resolution" });
    new import_obsidian.Setting(containerEl).setName("Open Editor on Conflict").setDesc("Open external editor when conflicts are detected").addToggle((toggle) => toggle.setValue(this.plugin.settings.openEditorOnConflict).onChange(async (value) => {
      this.plugin.settings.openEditorOnConflict = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Editor Command").setDesc("Command to open external editor").addText((text) => text.setPlaceholder("code .").setValue(this.plugin.settings.editorCommand).onChange(async (value) => {
      this.plugin.settings.editorCommand = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "AI Commit Messages" });
    new import_obsidian.Setting(containerEl).setName("Enable AI Commit Messages").setDesc("Use AI to generate commit messages based on changes").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAICommitMessages).onChange(async (value) => {
      this.plugin.settings.enableAICommitMessages = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("LLM Provider").setDesc("Choose your AI provider").addDropdown((dropdown) => dropdown.addOption("none", "None").addOption("openai", "OpenAI GPT").addOption("anthropic", "Anthropic Claude").setValue(this.plugin.settings.llmProvider).onChange(async (value) => {
      this.plugin.settings.llmProvider = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Your LLM API key (stored locally)").addText((text) => text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    })).addButton((button) => button.setButtonText("Test Connection").setTooltip("Test API connection").onClick(async () => {
      const result = await this.plugin.autoCommitService.testLLMConnection();
      if (result.success) {
        new import_obsidian.Notice("API connection successful!");
      } else {
        new import_obsidian.Notice(`API test failed: ${result.error}`);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Commit Prompt").setDesc("Custom prompt for commit message generation").addTextArea((text) => text.setPlaceholder("Generate a concise commit message for these changes:").setValue(this.plugin.settings.commitPrompt).onChange(async (value) => {
      this.plugin.settings.commitPrompt = value;
      await this.plugin.saveSettings();
    }));
  }
};
