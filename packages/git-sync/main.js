/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GitSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/git-service.ts
var import_simple_git = require("simple-git");
var GitService = class {
  constructor(repoPath) {
    this.repoPath = repoPath;
    this.git = (0, import_simple_git.simpleGit)(repoPath);
  }
  /**
   * Get the current git status
   */
  async getStatus() {
    try {
      const status = await this.git.status();
      const branch = await this.git.revparse(["--abbrev-ref", "HEAD"]);
      let ahead = 0;
      let behind = 0;
      try {
        const aheadBehind = await this.git.raw(["rev-list", "--left-right", "--count", `origin/${branch.trim()}...HEAD`]);
        const counts = aheadBehind.trim().split("	");
        behind = parseInt(counts[0]) || 0;
        ahead = parseInt(counts[1]) || 0;
      } catch (error) {
        console.warn("Could not get ahead/behind info:", error);
      }
      return {
        hasChanges: status.files.length > 0,
        staged: status.staged,
        unstaged: status.modified.concat(status.deleted),
        untracked: status.not_added,
        currentBranch: branch.trim(),
        ahead,
        behind
      };
    } catch (error) {
      console.error("Failed to get git status:", error);
      throw error;
    }
  }
  /**
   * Add files to staging area
   */
  async addFiles(files = ".", includeUntracked = true) {
    try {
      if (includeUntracked && files === ".") {
        await this.git.add(".");
      } else if (Array.isArray(files)) {
        await this.git.add(files);
      } else {
        await this.git.add([files]);
      }
      return { success: true };
    } catch (error) {
      console.error("Failed to add files:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Commit staged changes
   */
  async commit(message) {
    try {
      const result = await this.git.commit(message);
      return {
        success: true,
        data: {
          hash: result.commit,
          summary: result.summary
        }
      };
    } catch (error) {
      console.error("Failed to commit:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Add and commit in one operation
   */
  async addAndCommit(message, includeUntracked = true) {
    try {
      const status = await this.getStatus();
      if (!status.hasChanges) {
        return { success: true, data: { message: "No changes to commit" } };
      }
      const addResult = await this.addFiles(".", includeUntracked);
      if (!addResult.success) {
        return addResult;
      }
      const commitResult = await this.commit(message);
      return commitResult;
    } catch (error) {
      console.error("Failed to add and commit:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Push commits to remote
   */
  async push(branch) {
    try {
      if (branch) {
        await this.git.push("origin", branch);
      } else {
        await this.git.push();
      }
      return { success: true };
    } catch (error) {
      console.error("Failed to push:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Pull with rebase
   */
  async pullRebase(branch) {
    try {
      const result = await this.git.pull("origin", branch, { "--rebase": "true" });
      const status = await this.getStatus();
      const hasConflicts = status.unstaged.some(
        (file) => file.includes("<<<<<<< HEAD") || file.includes(">>>>>>> ")
      );
      return {
        success: true,
        conflicts: hasConflicts,
        data: result
      };
    } catch (error) {
      console.error("Failed to pull with rebase:", error);
      const isConflict = error.message.includes("conflict") || error.message.includes("CONFLICT");
      if (isConflict) {
        return { success: true, conflicts: true, error: error.message };
      }
      return { success: false, error: error.message };
    }
  }
  /**
   * Switch to a branch (create if it doesn't exist)
   */
  async switchBranch(branchName, createIfNotExists = true) {
    try {
      const branches = await this.git.branchLocal();
      const branchExists = branches.all.includes(branchName);
      if (!branchExists && createIfNotExists) {
        await this.git.checkoutLocalBranch(branchName);
      } else if (branchExists) {
        await this.git.checkout(branchName);
      } else {
        return { success: false, error: `Branch ${branchName} does not exist` };
      }
      return { success: true };
    } catch (error) {
      console.error("Failed to switch branch:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * Merge branches
   */
  async mergeBranches(fromBranch, toBranch, strategy = "merge") {
    try {
      const switchResult = await this.switchBranch(toBranch);
      if (!switchResult.success) {
        return switchResult;
      }
      let result;
      switch (strategy) {
        case "rebase":
          result = await this.git.rebase([fromBranch]);
          break;
        case "squash":
          result = await this.git.merge([fromBranch, "--squash"]);
          const status2 = await this.getStatus();
          if (status2.staged.length > 0) {
            await this.commit(`Squash merge ${fromBranch} into ${toBranch}`);
          }
          break;
        default:
          result = await this.git.merge([fromBranch]);
          break;
      }
      const status = await this.getStatus();
      const hasConflicts = status.unstaged.length > 0;
      return {
        success: true,
        conflicts: hasConflicts,
        data: result
      };
    } catch (error) {
      console.error("Failed to merge branches:", error);
      const isConflict = error.message.includes("conflict") || error.message.includes("CONFLICT");
      if (isConflict) {
        return { success: true, conflicts: true, error: error.message };
      }
      return { success: false, error: error.message };
    }
  }
  /**
   * Get current branch name
   */
  async getCurrentBranch() {
    try {
      const branch = await this.git.revparse(["--abbrev-ref", "HEAD"]);
      return branch.trim();
    } catch (error) {
      console.error("Failed to get current branch:", error);
      return "unknown";
    }
  }
  /**
   * Check if repository is clean (no uncommitted changes)
   */
  async isClean() {
    try {
      const status = await this.getStatus();
      return !status.hasChanges;
    } catch (error) {
      console.error("Failed to check if repo is clean:", error);
      return false;
    }
  }
  /**
   * Get list of recent commits
   */
  async getRecentCommits(count = 10) {
    try {
      const log = await this.git.log({ maxCount: count });
      return [...log.all];
    } catch (error) {
      console.error("Failed to get recent commits:", error);
      return [];
    }
  }
  /**
   * Check if remote repository is available
   */
  async checkRemoteConnection() {
    try {
      await this.git.listRemote(["--heads"]);
      return true;
    } catch (error) {
      console.warn("Remote connection check failed:", error);
      return false;
    }
  }
  /**
   * Initialize git repository if not already initialized
   */
  async initIfNeeded() {
    try {
      const isRepo = await this.git.checkIsRepo();
      if (!isRepo) {
        await this.git.init();
        return { success: true, data: { message: "Repository initialized" } };
      }
      return { success: true, data: { message: "Repository already exists" } };
    } catch (error) {
      console.error("Failed to initialize repository:", error);
      return { success: false, error: error.message };
    }
  }
};

// src/auto-commit-service.ts
var AutoCommitService = class {
  constructor(gitService, settings, vault) {
    this.intervalId = null;
    this.commitCount = 0;
    this.lastCommitTime = 0;
    this.gitService = gitService;
    this.settings = settings;
    this.vault = vault;
  }
  /**
   * Start the auto commit service
   */
  start() {
    if (this.intervalId) {
      this.stop();
    }
    if (!this.settings.enableAutoCommit) {
      return;
    }
    const intervalMs = this.settings.commitIntervalMinutes * 60 * 1e3;
    this.intervalId = setInterval(() => {
      this.performAutoCommit();
    }, intervalMs);
    console.log(`Auto commit service started with ${this.settings.commitIntervalMinutes} minute interval`);
  }
  /**
   * Stop the auto commit service
   */
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      console.log("Auto commit service stopped");
    }
  }
  /**
   * Update settings and restart if needed
   */
  updateSettings(settings) {
    this.settings = settings;
    if (this.settings.enableAutoCommit) {
      this.start();
    } else {
      this.stop();
    }
  }
  /**
   * Perform an automatic commit
   */
  async performAutoCommit() {
    var _a;
    try {
      console.log("Starting auto commit...");
      const currentBranch = await this.gitService.getCurrentBranch();
      if (currentBranch !== this.settings.tempBranch) {
        const switchResult = await this.gitService.switchBranch(this.settings.tempBranch);
        if (!switchResult.success) {
          return {
            success: false,
            error: `Failed to switch to ${this.settings.tempBranch}: ${switchResult.error}`
          };
        }
      }
      const status = await this.gitService.getStatus();
      if (!status.hasChanges) {
        console.log("No changes to commit");
        return {
          success: true,
          message: "No changes to commit"
        };
      }
      const commitMessage = await this.generateCommitMessage(status);
      const commitResult = await this.gitService.addAndCommit(
        commitMessage,
        this.settings.includeUntracked
      );
      if (!commitResult.success) {
        return {
          success: false,
          error: commitResult.error
        };
      }
      this.commitCount++;
      this.lastCommitTime = Date.now();
      console.log(`Auto commit successful: ${commitMessage}`);
      let pushResult = null;
      if (this.settings.enableAutoPush && this.commitCount >= this.settings.pushAfterCommits) {
        pushResult = await this.gitService.push(this.settings.tempBranch);
        if (pushResult.success) {
          this.commitCount = 0;
          console.log("Auto push successful");
        } else {
          console.warn("Auto push failed:", pushResult.error);
        }
      }
      return {
        success: true,
        message: commitMessage,
        filesChanged: status.staged.length + status.unstaged.length + status.untracked.length,
        hash: (_a = commitResult.data) == null ? void 0 : _a.hash
      };
    } catch (error) {
      console.error("Auto commit failed:", error);
      return {
        success: false,
        error: error.message
      };
    }
  }
  /**
   * Perform a manual commit (can be called from command)
   */
  async performCommit() {
    return this.performAutoCommit();
  }
  /**
   * Generate a commit message based on changes
   */
  async generateCommitMessage(status) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().slice(0, 19).replace("T", " ");
    const totalChanges = status.staged.length + status.unstaged.length + status.untracked.length;
    if (totalChanges === 0) {
      return `chore: auto commit at ${timestamp}`;
    }
    const categories = {
      added: status.untracked.length,
      modified: status.unstaged.filter((f) => !f.includes("deleted")).length,
      deleted: status.unstaged.filter((f) => f.includes("deleted")).length,
      staged: status.staged.length
    };
    const parts = [];
    if (categories.added > 0) {
      parts.push(`${categories.added} added`);
    }
    if (categories.modified > 0) {
      parts.push(`${categories.modified} modified`);
    }
    if (categories.deleted > 0) {
      parts.push(`${categories.deleted} deleted`);
    }
    let description = parts.join(", ");
    if (!description) {
      description = `${totalChanges} changes`;
    }
    const allFiles = [...status.staged, ...status.unstaged, ...status.untracked];
    const hasMarkdown = allFiles.some((f) => f.endsWith(".md"));
    const hasAttachments = allFiles.some(
      (f) => f.endsWith(".png") || f.endsWith(".jpg") || f.endsWith(".jpeg") || f.endsWith(".gif") || f.endsWith(".pdf")
    );
    const hasConfigs = allFiles.some(
      (f) => f.endsWith(".json") || f.endsWith(".yaml") || f.endsWith(".yml")
    );
    let prefix = "docs";
    if (hasMarkdown && !hasAttachments && !hasConfigs) {
      prefix = "docs";
    } else if (hasAttachments) {
      prefix = "assets";
    } else if (hasConfigs) {
      prefix = "config";
    } else {
      prefix = "update";
    }
    return `${prefix}: auto commit - ${description}

Auto-committed at ${timestamp}`;
  }
  /**
   * Get current commit count since last push
   */
  getCommitCount() {
    return this.commitCount;
  }
  /**
   * Get last commit time
   */
  getLastCommitTime() {
    return this.lastCommitTime;
  }
  /**
   * Reset commit counter (useful after manual push)
   */
  resetCommitCount() {
    this.commitCount = 0;
  }
  /**
   * Check if auto commit is due based on file modification times
   */
  async isCommitDue() {
    if (!this.settings.enableAutoCommit) {
      return false;
    }
    const now = Date.now();
    const intervalMs = this.settings.commitIntervalMinutes * 60 * 1e3;
    const timeSinceLastCommit = now - this.lastCommitTime;
    if (timeSinceLastCommit < intervalMs) {
      return false;
    }
    const status = await this.gitService.getStatus();
    return status.hasChanges;
  }
  /**
   * Get a summary of pending changes
   */
  async getPendingChangesSummary() {
    try {
      const status = await this.gitService.getStatus();
      return {
        hasChanges: status.hasChanges,
        totalFiles: status.staged.length + status.unstaged.length + status.untracked.length,
        added: status.staged.length,
        modified: status.unstaged.filter((f) => !f.includes("deleted")).length,
        deleted: status.unstaged.filter((f) => f.includes("deleted")).length,
        untracked: status.untracked.length
      };
    } catch (error) {
      console.error("Failed to get pending changes summary:", error);
      return {
        hasChanges: false,
        totalFiles: 0,
        added: 0,
        modified: 0,
        deleted: 0,
        untracked: 0
      };
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  // Branch settings
  tempBranch: "tmp",
  mainBranch: "main",
  // Auto commit settings
  enableAutoCommit: false,
  commitIntervalMinutes: 10,
  includeUntracked: true,
  // Auto push settings
  enableAutoPush: false,
  pushAfterCommits: 3,
  // LLM settings
  enableAICommitMessages: false,
  llmProvider: "none",
  apiKey: "",
  commitPrompt: "Generate a concise commit message for these changes:",
  // Auto pull settings
  enableAutoPull: false,
  pullOnStartup: true,
  // Merge settings
  enableAutoMerge: false,
  mergeStrategy: "merge",
  // Conflict resolution
  openEditorOnConflict: true,
  editorCommand: "code ."
};
var GitSyncPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.gitService = new GitService(this.app.vault.adapter.basePath || "");
    this.autoCommitService = new AutoCommitService(
      this.gitService,
      this.settings,
      this.app.vault
    );
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar("Git Sync Ready");
    this.addCommand({
      id: "manual-commit",
      name: "Manual Commit",
      callback: () => this.manualCommit()
    });
    this.addCommand({
      id: "manual-push",
      name: "Manual Push",
      callback: () => this.manualPush()
    });
    this.addCommand({
      id: "manual-pull",
      name: "Manual Pull",
      callback: () => this.manualPull()
    });
    this.addCommand({
      id: "switch-to-temp-branch",
      name: "Switch to Temp Branch",
      callback: () => this.switchToTempBranch()
    });
    this.addCommand({
      id: "merge-temp-to-main",
      name: "Merge Temp to Main",
      callback: () => this.mergeTempToMain()
    });
    this.addCommand({
      id: "toggle-auto-commit",
      name: "Toggle Auto Commit",
      callback: () => this.toggleAutoCommit()
    });
    this.addSettingTab(new GitSyncSettingTab(this.app, this));
    if (this.settings.enableAutoPull && this.settings.pullOnStartup) {
      this.performAutoPull();
    }
    if (this.settings.enableAutoCommit) {
      this.autoCommitService.start();
    }
    console.log("Git Sync plugin loaded");
  }
  onunload() {
    var _a;
    (_a = this.autoCommitService) == null ? void 0 : _a.stop();
    console.log("Git Sync plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.autoCommitService) {
      this.autoCommitService.updateSettings(this.settings);
      if (this.settings.enableAutoCommit) {
        this.autoCommitService.start();
      } else {
        this.autoCommitService.stop();
      }
    }
  }
  updateStatusBar(text) {
    this.statusBarItem.setText(`Git: ${text}`);
  }
  async manualCommit() {
    try {
      this.updateStatusBar("Committing...");
      const result = await this.autoCommitService.performCommit();
      if (result.success) {
        new import_obsidian.Notice(`Committed: ${result.message}`);
        this.updateStatusBar("Commit successful");
      } else {
        new import_obsidian.Notice(`Commit failed: ${result.error}`);
        this.updateStatusBar("Commit failed");
      }
    } catch (error) {
      console.error("Manual commit error:", error);
      new import_obsidian.Notice(`Commit error: ${error.message}`);
      this.updateStatusBar("Commit error");
    }
  }
  async manualPush() {
    try {
      this.updateStatusBar("Pushing...");
      const result = await this.gitService.push();
      if (result.success) {
        new import_obsidian.Notice("Push successful");
        this.updateStatusBar("Push successful");
      } else {
        new import_obsidian.Notice(`Push failed: ${result.error}`);
        this.updateStatusBar("Push failed");
      }
    } catch (error) {
      console.error("Manual push error:", error);
      new import_obsidian.Notice(`Push error: ${error.message}`);
      this.updateStatusBar("Push error");
    }
  }
  async manualPull() {
    try {
      this.updateStatusBar("Pulling...");
      await this.performAutoPull();
    } catch (error) {
      console.error("Manual pull error:", error);
      new import_obsidian.Notice(`Pull error: ${error.message}`);
      this.updateStatusBar("Pull error");
    }
  }
  async performAutoPull() {
    try {
      const result = await this.gitService.pullRebase();
      if (result.success) {
        new import_obsidian.Notice("Pull successful");
        this.updateStatusBar("Pull successful");
      } else if (result.conflicts) {
        new import_obsidian.Notice("Pull completed with conflicts - please resolve manually");
        this.updateStatusBar("Conflicts detected");
        if (this.settings.openEditorOnConflict) {
          this.openExternalEditor();
        }
      } else {
        new import_obsidian.Notice(`Pull failed: ${result.error}`);
        this.updateStatusBar("Pull failed");
      }
    } catch (error) {
      console.error("Auto pull error:", error);
      new import_obsidian.Notice(`Pull error: ${error.message}`);
      this.updateStatusBar("Pull error");
    }
  }
  async switchToTempBranch() {
    try {
      this.updateStatusBar("Switching branch...");
      const result = await this.gitService.switchBranch(this.settings.tempBranch);
      if (result.success) {
        new import_obsidian.Notice(`Switched to ${this.settings.tempBranch} branch`);
        this.updateStatusBar(`On ${this.settings.tempBranch}`);
      } else {
        new import_obsidian.Notice(`Failed to switch branch: ${result.error}`);
        this.updateStatusBar("Branch switch failed");
      }
    } catch (error) {
      console.error("Switch branch error:", error);
      new import_obsidian.Notice(`Branch switch error: ${error.message}`);
      this.updateStatusBar("Branch switch error");
    }
  }
  async mergeTempToMain() {
    try {
      this.updateStatusBar("Merging...");
      const result = await this.gitService.mergeBranches(
        this.settings.tempBranch,
        this.settings.mainBranch,
        this.settings.mergeStrategy
      );
      if (result.success) {
        new import_obsidian.Notice(`Merged ${this.settings.tempBranch} to ${this.settings.mainBranch}`);
        this.updateStatusBar("Merge successful");
      } else if (result.conflicts) {
        new import_obsidian.Notice("Merge completed with conflicts - please resolve manually");
        this.updateStatusBar("Merge conflicts");
        if (this.settings.openEditorOnConflict) {
          this.openExternalEditor();
        }
      } else {
        new import_obsidian.Notice(`Merge failed: ${result.error}`);
        this.updateStatusBar("Merge failed");
      }
    } catch (error) {
      console.error("Merge error:", error);
      new import_obsidian.Notice(`Merge error: ${error.message}`);
      this.updateStatusBar("Merge error");
    }
  }
  toggleAutoCommit() {
    this.settings.enableAutoCommit = !this.settings.enableAutoCommit;
    this.saveSettings();
    const status = this.settings.enableAutoCommit ? "enabled" : "disabled";
    new import_obsidian.Notice(`Auto commit ${status}`);
    this.updateStatusBar(`Auto commit ${status}`);
  }
  openExternalEditor() {
    try {
      const { exec } = require("child_process");
      exec(this.settings.editorCommand, { cwd: this.app.vault.adapter.basePath || "" });
    } catch (error) {
      console.error("Failed to open external editor:", error);
      new import_obsidian.Notice("Failed to open external editor");
    }
  }
};
var GitSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Git Sync Settings" });
    containerEl.createEl("h3", { text: "Branch Settings" });
    new import_obsidian.Setting(containerEl).setName("Temp Branch Name").setDesc("Name of the temporary branch for auto commits").addText((text) => text.setPlaceholder("tmp").setValue(this.plugin.settings.tempBranch).onChange(async (value) => {
      this.plugin.settings.tempBranch = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Main Branch Name").setDesc("Name of the main branch to merge into").addText((text) => text.setPlaceholder("main").setValue(this.plugin.settings.mainBranch).onChange(async (value) => {
      this.plugin.settings.mainBranch = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto Commit Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Auto Commit").setDesc("Automatically commit changes at regular intervals").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoCommit).onChange(async (value) => {
      this.plugin.settings.enableAutoCommit = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Commit Interval (minutes)").setDesc("How often to commit changes").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.commitIntervalMinutes).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.commitIntervalMinutes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include Untracked Files").setDesc("Include new files in auto commits").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeUntracked).onChange(async (value) => {
      this.plugin.settings.includeUntracked = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto Push Settings" });
    new import_obsidian.Setting(containerEl).setName("Enable Auto Push").setDesc("Automatically push commits to remote").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoPush).onChange(async (value) => {
      this.plugin.settings.enableAutoPush = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Push After Commits").setDesc("Number of commits before auto pushing").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.pushAfterCommits).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.pushAfterCommits = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Auto Pull Settings" });
    new import_obsidian.Setting(containerEl).setName("Pull on Startup").setDesc("Automatically pull latest changes when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.pullOnStartup).onChange(async (value) => {
      this.plugin.settings.pullOnStartup = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Merge Settings" });
    new import_obsidian.Setting(containerEl).setName("Merge Strategy").setDesc("How to merge temp branch into main").addDropdown((dropdown) => dropdown.addOption("merge", "Merge").addOption("rebase", "Rebase").addOption("squash", "Squash").setValue(this.plugin.settings.mergeStrategy).onChange(async (value) => {
      this.plugin.settings.mergeStrategy = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Conflict Resolution" });
    new import_obsidian.Setting(containerEl).setName("Open Editor on Conflict").setDesc("Open external editor when conflicts are detected").addToggle((toggle) => toggle.setValue(this.plugin.settings.openEditorOnConflict).onChange(async (value) => {
      this.plugin.settings.openEditorOnConflict = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Editor Command").setDesc("Command to open external editor").addText((text) => text.setPlaceholder("code .").setValue(this.plugin.settings.editorCommand).onChange(async (value) => {
      this.plugin.settings.editorCommand = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "AI Commit Messages (Coming Soon)" });
    new import_obsidian.Setting(containerEl).setName("Enable AI Commit Messages").setDesc("Use AI to generate commit messages (future feature)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAICommitMessages).setDisabled(true).onChange(async (value) => {
      this.plugin.settings.enableAICommitMessages = value;
      await this.plugin.saveSettings();
    }));
  }
};
